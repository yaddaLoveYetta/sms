##连接设置
#链接驱动陈程序
#改用sqlserver数据库
jdbc.driverClass=com.microsoft.sqlserver.jdbc.SQLServerDriver
jdbc.jdbcUrl=jdbc:sqlserver://10.0.0.180:1433;database=hrp-sms
jdbc.user = sa
jdbc.password =Kingdee123

#jdbc.jdbcUrl=jdbc:sqlserver://127.0.0.1:52663;database=hrp-sms
#jdbc.user = sa
#jdbc.password =yadda0925
#jdbc.jdbcUrl=jdbc:sqlserver://192.168.1.101:1433;database=hrp-sms
#jdbc.user = sa
#jdbc.password =yadda0925

#<!--连接池中保留的最大连接数。默认值: 15 -->  
jdbc.maxPoolSize=5
#<!-- 连接池中保留的最小连接数，默认为：3-->  
jdbc.minPoolSize=2
#<!-- 初始化连接池中的连接数，取值应在minPoolSize与maxPoolSize之间，默认为3--> 
jdbc.initialPoolSize=3
#<!--最大空闲时间，25000秒内未使用则连接被丢弃。若为0则永不丢弃。默认值: 0 -->  
jdbc.maxIdleTime=25000
#<!-- 当连接池连接耗尽时，客户端调用getConnection()后等待获取新连接的时间，超时后将抛出SQLException，如设为0则无限期等待。单位毫秒。默认: 0 -->   
jdbc.maxWait=6000
#有些数据库连接的时候有超时限制（MySQL连接在8小时后断开），或者由于网络中断等原因，连接池的连接会出现失效的情况，
#这时候可以设置一个testWhileIdle参数为true， 如果检测到当前连接不活跃的时间超过了timeBetweenEvictionRunsMillis，
#则去手动检测一下当前连接的有效性，在保证确实有效后才加以使用。 
#在检测活跃性时，如果当前的活跃时间大于minEvictableIdleTimeMillis，则认为需要关闭当前连接。
#当然，为了保证绝对的可用性，你也可以使用testOnBorrow为true（即在每次获取Connection对象时都检测其可用性），不过这样会影响性能。
#配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒（3600000:为1小时）
jdbc.timeBetweenEvictionRunsMillis=10000
#配置一个连接在池中最小生存的时间，单位是毫秒(300000:为5分钟)
jdbc.minEvictableIdleTimeMillis=300000
#申请连接的时候检测，如果空闲时间大于timeBetweenEvictionRunsMillis，
#执行validationQuery检测连接是否有效。建议配置为true，不影响性能，并且保证安全性
jdbc.testWhileIdle=true
#申请连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。缺省值:true
jdbc.testOnBorrow=false
#归还连接时执行validationQuery检测连接是否有效，做了这个配置会降低性能。缺省值:false
jdbc.testOnReturn=false
#<!--当连接池中的连接耗尽的时候c3p0一次同时获取的连接数。默认值: 3 --> 
jdbc.acquireIncrement=5
#<!--定义在从数据库获取新连接失败后重复尝试的次数。默认值: 30 ；小于等于0表示无限次-->  
jdbc.acquireRetryAttempts=30
#<!--重新尝试的时间间隔，默认为：1000毫秒-->   
jdbc.acquireRetryDelay=1000
#<!--关闭连接时，是否提交未提交的事务，默认为false，即关闭连接，回滚未提交的事务 -->  
jdbc.autoCommitOnClose=false
#<!--c3p0将建一张名为Test的空表，并使用其自带的查询语句进行测试。如果定义了这个参数那么属性preferredTestQuery将被忽略。你不能在这张Test表上进行任何操作，它将只供c3p0测试使用。默认值: null -->
#<!-- automaticTestTable maked error: CLOSE BY CLIENT STACK TRACE -->  
#获取connnection时测试是否有效
jdbc.testConnectionOnCheckin = true
jdbc.testConnectionOnCheckout = true
jdbc.automaticTestTable=t_sms_validation
#<!--如果为false，则获取连接失败将会引起所有等待连接池来获取连接的线程抛出异常，但是数据源仍有效保留，并在下次调用getConnection()的时候继续尝试获取连接。如果设为true，那么在尝试获取连接失败后该数据源将申明已断开并永久关闭。默认: false--> 
jdbc.breakAfterAcquireFailure=false
#<!--每18000秒检查所有连接池中的空闲连接。默认值: 0，不检查 --> 
jdbc.idleConnectionTestPeriod=18000
#<!--c3p0全局的PreparedStatements缓存的大小。如果maxStatements与maxStatementsPerConnection均为0，则缓存不生效，只要有一个不为0，则语句的缓存就能生效。如果默认值: 0-->
jdbc.maxStatements=100
#<!--maxStatementsPerConnection定义了连接池内单个连接所拥有的最大缓存statements数。默认值: 0 --> 
jdbc.maxStatementsPerConnection=20
#<!--为0的时候要求所有的Connection在应用程序中必须关闭。如果不为0，则强制在设定的时间到达后回收Connection,默认值 0单位 秒 -->
jdbc.unreturnedConnectionTimeout=60
#<!--配置连接的生存时间，超过这个时间的连接将由连接池自动断开丢弃掉。当然正在使用的连接不会马上断开，而是等待它close再断开。配置为0的时候则不会对连接的生存时间进行限制,默认值 0单位 秒 -->
jdbc.maxIdleTimeExcessConnections=60
#<!--秒，有效生存时间。一个比maxconnectionage就从池中移除，从池中清除旧的连接。这不同于maxidletime，它指的是绝对年龄。当前存在的链接超过了maxconnectionage值就从池中删掉，不管当前的链接数量是否充足，0表示永久有效 ，默认0 -->
jdbc.maxConnectionAge=60
#druid检测连接存活sql
jdbc.validationQuery=SELECT 1 FROM t_sms_validation
#打开PSCache，并且指定每个连接上PSCache的大小
#是否缓存preparedStatement，也就是PSCache。PSCache对支持游标的数据库性能提升巨大，
#比如说oracle。在mysql5.5以下的版本中没有PSCache功能，建议关闭掉。5.5及以上版本有PSCache，建议开启。缺省值:false 
jdbc.poolPreparedStatements=true
#要启用PSCache，必须配置大于0，当大于0时，poolPreparedStatements自动触发修改为true。
#在Druid中，不会存在Oracle下PSCache占用内存过多的问题，可以把这个数值配置大一些，比如说100
jdbc.maxPoolPreparedStatementPerConnectionSize=20
#对于建立连接过长的连接强制关闭  
jdbc.removeAbandoned=true  
#如果连接建立时间超过了30分钟，则强制将其关闭,单位秒
jdbc.removeAbandonedTimeout=10
#关闭abanded连接时输出错误日志 
jdbc.logAbandoned=true



